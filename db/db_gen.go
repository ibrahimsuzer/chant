// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
// +build !codeanalysis

package db

import (
	"context"
	"testing"

	"github.com/prisma/prisma-client-go/engine"
	"github.com/prisma/prisma-client-go/engine/mock"
	"github.com/prisma/prisma-client-go/runtime/builder"
	"github.com/prisma/prisma-client-go/runtime/lifecycle"
	"github.com/prisma/prisma-client-go/runtime/raw"
	"github.com/prisma/prisma-client-go/runtime/transaction"
	"github.com/prisma/prisma-client-go/runtime/types"

	// no-op import for go modules
	_ "github.com/iancoleman/strcase"
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"
	_ "github.com/takuoki/gocase"
)

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type BatchResult = types.BatchResult

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type Direction = types.Direction

const (
	ASC  Direction = types.ASC
	DESC Direction = types.DESC
)

const RFC3339Milli = types.RFC3339Milli

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type dotfileActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var dotfileOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "name"},
	{Name: "path"},
	{Name: "extension"},
	{Name: "mimeType"},
	{Name: "language"},
	{Name: "currentId"},
}

type iDotfileRelationWith interface {
	getQuery() builder.Query
	with()
	dotfileRelation()
}

type DotfileWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
}

type dotfileDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileDefaultParam) field() builder.Field {
	return p.data
}

func (p dotfileDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileDefaultParam) dotfileModel() {}

type iDotfileOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
}

type dotfileOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileOrderByParam) field() builder.Field {
	return p.data
}

func (p dotfileOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileOrderByParam) dotfileModel() {}

type iDotfileCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	isCursor()
}

type dotfileCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileCursorParam) field() builder.Field {
	return p.data
}

func (p dotfileCursorParam) isCursor() {}

func (p dotfileCursorParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileCursorParam) dotfileModel() {}

type DotfileParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	dotfileModel()
}

type dotfileParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileParamUnique) dotfileModel() {}

func (dotfileParamUnique) unique() {}

func (p dotfileParamUnique) field() builder.Field {
	return p.data
}

func (p dotfileParamUnique) getQuery() builder.Query {
	return p.query
}

type DotfileEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
}

type dotfileEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileEqualsParam) dotfileModel() {}

func (dotfileEqualsParam) equals() {}

func (p dotfileEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileEqualsParam) getQuery() builder.Query {
	return p.query
}

type DotfileEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	dotfileModel()
}

type dotfileEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileEqualsUniqueParam) dotfileModel() {}

func (dotfileEqualsUniqueParam) unique() {}
func (dotfileEqualsUniqueParam) equals() {}

func (p dotfileEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DotfileSetParam interface {
	field() builder.Field
	settable()
	dotfileModel()
}

type dotfileSetParam struct {
	data builder.Field
}

func (dotfileSetParam) settable() {}

func (p dotfileSetParam) field() builder.Field {
	return p.data
}

func (p dotfileSetParam) dotfileModel() {}

type DotfileWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	idField()
}

type DotfileWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	idField()
}

type dotfileWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaIDSetParam) dotfileModel() {}

func (p dotfileWithPrismaIDSetParam) idField() {}

type DotfileWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	idField()
}

type dotfileWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaIDEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaIDEqualsParam) idField() {}

func (dotfileWithPrismaIDSetParam) settable()  {}
func (dotfileWithPrismaIDEqualsParam) equals() {}

type dotfileWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaIDEqualsUniqueParam) dotfileModel() {}
func (p dotfileWithPrismaIDEqualsUniqueParam) idField()      {}

func (dotfileWithPrismaIDEqualsUniqueParam) unique() {}
func (dotfileWithPrismaIDEqualsUniqueParam) equals() {}

type DotfileWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	createdAtField()
}

type DotfileWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	createdAtField()
}

type dotfileWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCreatedAtSetParam) dotfileModel() {}

func (p dotfileWithPrismaCreatedAtSetParam) createdAtField() {}

type DotfileWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	createdAtField()
}

type dotfileWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCreatedAtEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (dotfileWithPrismaCreatedAtSetParam) settable()  {}
func (dotfileWithPrismaCreatedAtEqualsParam) equals() {}

type dotfileWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCreatedAtEqualsUniqueParam) dotfileModel()   {}
func (p dotfileWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (dotfileWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (dotfileWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type DotfileWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	updatedAtField()
}

type DotfileWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	updatedAtField()
}

type dotfileWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaUpdatedAtSetParam) dotfileModel() {}

func (p dotfileWithPrismaUpdatedAtSetParam) updatedAtField() {}

type DotfileWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	updatedAtField()
}

type dotfileWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaUpdatedAtEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (dotfileWithPrismaUpdatedAtSetParam) settable()  {}
func (dotfileWithPrismaUpdatedAtEqualsParam) equals() {}

type dotfileWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaUpdatedAtEqualsUniqueParam) dotfileModel()   {}
func (p dotfileWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (dotfileWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (dotfileWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type DotfileWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	nameField()
}

type DotfileWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	nameField()
}

type dotfileWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaNameSetParam) dotfileModel() {}

func (p dotfileWithPrismaNameSetParam) nameField() {}

type DotfileWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	nameField()
}

type dotfileWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaNameEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaNameEqualsParam) nameField() {}

func (dotfileWithPrismaNameSetParam) settable()  {}
func (dotfileWithPrismaNameEqualsParam) equals() {}

type dotfileWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaNameEqualsUniqueParam) dotfileModel() {}
func (p dotfileWithPrismaNameEqualsUniqueParam) nameField()    {}

func (dotfileWithPrismaNameEqualsUniqueParam) unique() {}
func (dotfileWithPrismaNameEqualsUniqueParam) equals() {}

type DotfileWithPrismaPathEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	pathField()
}

type DotfileWithPrismaPathSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	pathField()
}

type dotfileWithPrismaPathSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaPathSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaPathSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaPathSetParam) dotfileModel() {}

func (p dotfileWithPrismaPathSetParam) pathField() {}

type DotfileWithPrismaPathWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	pathField()
}

type dotfileWithPrismaPathEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaPathEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaPathEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaPathEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaPathEqualsParam) pathField() {}

func (dotfileWithPrismaPathSetParam) settable()  {}
func (dotfileWithPrismaPathEqualsParam) equals() {}

type dotfileWithPrismaPathEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaPathEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaPathEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaPathEqualsUniqueParam) dotfileModel() {}
func (p dotfileWithPrismaPathEqualsUniqueParam) pathField()    {}

func (dotfileWithPrismaPathEqualsUniqueParam) unique() {}
func (dotfileWithPrismaPathEqualsUniqueParam) equals() {}

type DotfileWithPrismaExtensionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	extensionField()
}

type DotfileWithPrismaExtensionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	extensionField()
}

type dotfileWithPrismaExtensionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaExtensionSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaExtensionSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaExtensionSetParam) dotfileModel() {}

func (p dotfileWithPrismaExtensionSetParam) extensionField() {}

type DotfileWithPrismaExtensionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	extensionField()
}

type dotfileWithPrismaExtensionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaExtensionEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaExtensionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaExtensionEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaExtensionEqualsParam) extensionField() {}

func (dotfileWithPrismaExtensionSetParam) settable()  {}
func (dotfileWithPrismaExtensionEqualsParam) equals() {}

type dotfileWithPrismaExtensionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaExtensionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaExtensionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaExtensionEqualsUniqueParam) dotfileModel()   {}
func (p dotfileWithPrismaExtensionEqualsUniqueParam) extensionField() {}

func (dotfileWithPrismaExtensionEqualsUniqueParam) unique() {}
func (dotfileWithPrismaExtensionEqualsUniqueParam) equals() {}

type DotfileWithPrismaMimeTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	mimeTypeField()
}

type DotfileWithPrismaMimeTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	mimeTypeField()
}

type dotfileWithPrismaMimeTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaMimeTypeSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaMimeTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaMimeTypeSetParam) dotfileModel() {}

func (p dotfileWithPrismaMimeTypeSetParam) mimeTypeField() {}

type DotfileWithPrismaMimeTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	mimeTypeField()
}

type dotfileWithPrismaMimeTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaMimeTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaMimeTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaMimeTypeEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaMimeTypeEqualsParam) mimeTypeField() {}

func (dotfileWithPrismaMimeTypeSetParam) settable()  {}
func (dotfileWithPrismaMimeTypeEqualsParam) equals() {}

type dotfileWithPrismaMimeTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaMimeTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaMimeTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaMimeTypeEqualsUniqueParam) dotfileModel()  {}
func (p dotfileWithPrismaMimeTypeEqualsUniqueParam) mimeTypeField() {}

func (dotfileWithPrismaMimeTypeEqualsUniqueParam) unique() {}
func (dotfileWithPrismaMimeTypeEqualsUniqueParam) equals() {}

type DotfileWithPrismaLanguageEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	languageField()
}

type DotfileWithPrismaLanguageSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	languageField()
}

type dotfileWithPrismaLanguageSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaLanguageSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaLanguageSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaLanguageSetParam) dotfileModel() {}

func (p dotfileWithPrismaLanguageSetParam) languageField() {}

type DotfileWithPrismaLanguageWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	languageField()
}

type dotfileWithPrismaLanguageEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaLanguageEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaLanguageEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaLanguageEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaLanguageEqualsParam) languageField() {}

func (dotfileWithPrismaLanguageSetParam) settable()  {}
func (dotfileWithPrismaLanguageEqualsParam) equals() {}

type dotfileWithPrismaLanguageEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaLanguageEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaLanguageEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaLanguageEqualsUniqueParam) dotfileModel()  {}
func (p dotfileWithPrismaLanguageEqualsUniqueParam) languageField() {}

func (dotfileWithPrismaLanguageEqualsUniqueParam) unique() {}
func (dotfileWithPrismaLanguageEqualsUniqueParam) equals() {}

type DotfileWithPrismaCurrentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	currentField()
}

type DotfileWithPrismaCurrentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	currentField()
}

type dotfileWithPrismaCurrentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCurrentSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCurrentSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCurrentSetParam) dotfileModel() {}

func (p dotfileWithPrismaCurrentSetParam) currentField() {}

type DotfileWithPrismaCurrentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	currentField()
}

type dotfileWithPrismaCurrentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCurrentEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCurrentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCurrentEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaCurrentEqualsParam) currentField() {}

func (dotfileWithPrismaCurrentSetParam) settable()  {}
func (dotfileWithPrismaCurrentEqualsParam) equals() {}

type dotfileWithPrismaCurrentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCurrentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCurrentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCurrentEqualsUniqueParam) dotfileModel() {}
func (p dotfileWithPrismaCurrentEqualsUniqueParam) currentField() {}

func (dotfileWithPrismaCurrentEqualsUniqueParam) unique() {}
func (dotfileWithPrismaCurrentEqualsUniqueParam) equals() {}

type DotfileWithPrismaCurrentIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	currentIDField()
}

type DotfileWithPrismaCurrentIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	currentIDField()
}

type dotfileWithPrismaCurrentIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCurrentIDSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCurrentIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCurrentIDSetParam) dotfileModel() {}

func (p dotfileWithPrismaCurrentIDSetParam) currentIDField() {}

type DotfileWithPrismaCurrentIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	currentIDField()
}

type dotfileWithPrismaCurrentIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCurrentIDEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCurrentIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCurrentIDEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaCurrentIDEqualsParam) currentIDField() {}

func (dotfileWithPrismaCurrentIDSetParam) settable()  {}
func (dotfileWithPrismaCurrentIDEqualsParam) equals() {}

type dotfileWithPrismaCurrentIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaCurrentIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaCurrentIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaCurrentIDEqualsUniqueParam) dotfileModel()   {}
func (p dotfileWithPrismaCurrentIDEqualsUniqueParam) currentIDField() {}

func (dotfileWithPrismaCurrentIDEqualsUniqueParam) unique() {}
func (dotfileWithPrismaCurrentIDEqualsUniqueParam) equals() {}

type DotfileWithPrismaVersionsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	dotfileModel()
	versionsField()
}

type DotfileWithPrismaVersionsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	versionsField()
}

type dotfileWithPrismaVersionsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaVersionsSetParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaVersionsSetParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaVersionsSetParam) dotfileModel() {}

func (p dotfileWithPrismaVersionsSetParam) versionsField() {}

type DotfileWithPrismaVersionsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	dotfileModel()
	versionsField()
}

type dotfileWithPrismaVersionsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaVersionsEqualsParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaVersionsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaVersionsEqualsParam) dotfileModel() {}

func (p dotfileWithPrismaVersionsEqualsParam) versionsField() {}

func (dotfileWithPrismaVersionsSetParam) settable()  {}
func (dotfileWithPrismaVersionsEqualsParam) equals() {}

type dotfileWithPrismaVersionsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p dotfileWithPrismaVersionsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p dotfileWithPrismaVersionsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p dotfileWithPrismaVersionsEqualsUniqueParam) dotfileModel()  {}
func (p dotfileWithPrismaVersionsEqualsUniqueParam) versionsField() {}

func (dotfileWithPrismaVersionsEqualsUniqueParam) unique() {}
func (dotfileWithPrismaVersionsEqualsUniqueParam) equals() {}

type fileVersionActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var fileVersionOutput = []builder.Output{
	{Name: "id"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "content"},
	{Name: "hash"},
	{Name: "fileId"},
	{Name: "predecessorId"},
}

type iFileVersionRelationWith interface {
	getQuery() builder.Query
	with()
	fileVersionRelation()
}

type FileVersionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
}

type fileVersionDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionDefaultParam) field() builder.Field {
	return p.data
}

func (p fileVersionDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionDefaultParam) fileVersionModel() {}

type iFileVersionOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
}

type fileVersionOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionOrderByParam) field() builder.Field {
	return p.data
}

func (p fileVersionOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionOrderByParam) fileVersionModel() {}

type iFileVersionCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	isCursor()
}

type fileVersionCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionCursorParam) field() builder.Field {
	return p.data
}

func (p fileVersionCursorParam) isCursor() {}

func (p fileVersionCursorParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionCursorParam) fileVersionModel() {}

type FileVersionParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	fileVersionModel()
}

type fileVersionParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionParamUnique) fileVersionModel() {}

func (fileVersionParamUnique) unique() {}

func (p fileVersionParamUnique) field() builder.Field {
	return p.data
}

func (p fileVersionParamUnique) getQuery() builder.Query {
	return p.query
}

type FileVersionEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
}

type fileVersionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionEqualsParam) fileVersionModel() {}

func (fileVersionEqualsParam) equals() {}

func (p fileVersionEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionEqualsParam) getQuery() builder.Query {
	return p.query
}

type FileVersionEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	fileVersionModel()
}

type fileVersionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionEqualsUniqueParam) fileVersionModel() {}

func (fileVersionEqualsUniqueParam) unique() {}
func (fileVersionEqualsUniqueParam) equals() {}

func (p fileVersionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type FileVersionSetParam interface {
	field() builder.Field
	settable()
	fileVersionModel()
}

type fileVersionSetParam struct {
	data builder.Field
}

func (fileVersionSetParam) settable() {}

func (p fileVersionSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionSetParam) fileVersionModel() {}

type FileVersionWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	idField()
}

type FileVersionWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	idField()
}

type fileVersionWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaIDSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaIDSetParam) idField() {}

type FileVersionWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	idField()
}

type fileVersionWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaIDEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaIDEqualsParam) idField() {}

func (fileVersionWithPrismaIDSetParam) settable()  {}
func (fileVersionWithPrismaIDEqualsParam) equals() {}

type fileVersionWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaIDEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaIDEqualsUniqueParam) idField()          {}

func (fileVersionWithPrismaIDEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaIDEqualsUniqueParam) equals() {}

type FileVersionWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	createdAtField()
}

type FileVersionWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	createdAtField()
}

type fileVersionWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaCreatedAtSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaCreatedAtSetParam) createdAtField() {}

type FileVersionWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	createdAtField()
}

type fileVersionWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaCreatedAtEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (fileVersionWithPrismaCreatedAtSetParam) settable()  {}
func (fileVersionWithPrismaCreatedAtEqualsParam) equals() {}

type fileVersionWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaCreatedAtEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaCreatedAtEqualsUniqueParam) createdAtField()   {}

func (fileVersionWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type FileVersionWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	updatedAtField()
}

type FileVersionWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	updatedAtField()
}

type fileVersionWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaUpdatedAtSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaUpdatedAtSetParam) updatedAtField() {}

type FileVersionWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	updatedAtField()
}

type fileVersionWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaUpdatedAtEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (fileVersionWithPrismaUpdatedAtSetParam) settable()  {}
func (fileVersionWithPrismaUpdatedAtEqualsParam) equals() {}

type fileVersionWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaUpdatedAtEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField()   {}

func (fileVersionWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type FileVersionWithPrismaContentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	contentField()
}

type FileVersionWithPrismaContentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	contentField()
}

type fileVersionWithPrismaContentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaContentSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaContentSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaContentSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaContentSetParam) contentField() {}

type FileVersionWithPrismaContentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	contentField()
}

type fileVersionWithPrismaContentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaContentEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaContentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaContentEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaContentEqualsParam) contentField() {}

func (fileVersionWithPrismaContentSetParam) settable()  {}
func (fileVersionWithPrismaContentEqualsParam) equals() {}

type fileVersionWithPrismaContentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaContentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaContentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaContentEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaContentEqualsUniqueParam) contentField()     {}

func (fileVersionWithPrismaContentEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaContentEqualsUniqueParam) equals() {}

type FileVersionWithPrismaHashEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	hashField()
}

type FileVersionWithPrismaHashSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	hashField()
}

type fileVersionWithPrismaHashSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaHashSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaHashSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaHashSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaHashSetParam) hashField() {}

type FileVersionWithPrismaHashWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	hashField()
}

type fileVersionWithPrismaHashEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaHashEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaHashEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaHashEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaHashEqualsParam) hashField() {}

func (fileVersionWithPrismaHashSetParam) settable()  {}
func (fileVersionWithPrismaHashEqualsParam) equals() {}

type fileVersionWithPrismaHashEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaHashEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaHashEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaHashEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaHashEqualsUniqueParam) hashField()        {}

func (fileVersionWithPrismaHashEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaHashEqualsUniqueParam) equals() {}

type FileVersionWithPrismaCurrentlyUsedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	currentlyUsedField()
}

type FileVersionWithPrismaCurrentlyUsedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	currentlyUsedField()
}

type fileVersionWithPrismaCurrentlyUsedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaCurrentlyUsedSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaCurrentlyUsedSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaCurrentlyUsedSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaCurrentlyUsedSetParam) currentlyUsedField() {}

type FileVersionWithPrismaCurrentlyUsedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	currentlyUsedField()
}

type fileVersionWithPrismaCurrentlyUsedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaCurrentlyUsedEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaCurrentlyUsedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaCurrentlyUsedEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaCurrentlyUsedEqualsParam) currentlyUsedField() {}

func (fileVersionWithPrismaCurrentlyUsedSetParam) settable()  {}
func (fileVersionWithPrismaCurrentlyUsedEqualsParam) equals() {}

type fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam) fileVersionModel()   {}
func (p fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam) currentlyUsedField() {}

func (fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaCurrentlyUsedEqualsUniqueParam) equals() {}

type FileVersionWithPrismaFileEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	fileField()
}

type FileVersionWithPrismaFileSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	fileField()
}

type fileVersionWithPrismaFileSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaFileSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaFileSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaFileSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaFileSetParam) fileField() {}

type FileVersionWithPrismaFileWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	fileField()
}

type fileVersionWithPrismaFileEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaFileEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaFileEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaFileEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaFileEqualsParam) fileField() {}

func (fileVersionWithPrismaFileSetParam) settable()  {}
func (fileVersionWithPrismaFileEqualsParam) equals() {}

type fileVersionWithPrismaFileEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaFileEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaFileEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaFileEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaFileEqualsUniqueParam) fileField()        {}

func (fileVersionWithPrismaFileEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaFileEqualsUniqueParam) equals() {}

type FileVersionWithPrismaFileIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	fileIDField()
}

type FileVersionWithPrismaFileIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	fileIDField()
}

type fileVersionWithPrismaFileIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaFileIDSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaFileIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaFileIDSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaFileIDSetParam) fileIDField() {}

type FileVersionWithPrismaFileIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	fileIDField()
}

type fileVersionWithPrismaFileIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaFileIDEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaFileIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaFileIDEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaFileIDEqualsParam) fileIDField() {}

func (fileVersionWithPrismaFileIDSetParam) settable()  {}
func (fileVersionWithPrismaFileIDEqualsParam) equals() {}

type fileVersionWithPrismaFileIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaFileIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaFileIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaFileIDEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaFileIDEqualsUniqueParam) fileIDField()      {}

func (fileVersionWithPrismaFileIDEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaFileIDEqualsUniqueParam) equals() {}

type FileVersionWithPrismaSuccessorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	successorField()
}

type FileVersionWithPrismaSuccessorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	successorField()
}

type fileVersionWithPrismaSuccessorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaSuccessorSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaSuccessorSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaSuccessorSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaSuccessorSetParam) successorField() {}

type FileVersionWithPrismaSuccessorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	successorField()
}

type fileVersionWithPrismaSuccessorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaSuccessorEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaSuccessorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaSuccessorEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaSuccessorEqualsParam) successorField() {}

func (fileVersionWithPrismaSuccessorSetParam) settable()  {}
func (fileVersionWithPrismaSuccessorEqualsParam) equals() {}

type fileVersionWithPrismaSuccessorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaSuccessorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaSuccessorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaSuccessorEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaSuccessorEqualsUniqueParam) successorField()   {}

func (fileVersionWithPrismaSuccessorEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaSuccessorEqualsUniqueParam) equals() {}

type FileVersionWithPrismaPredecessorEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	predecessorField()
}

type FileVersionWithPrismaPredecessorSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	predecessorField()
}

type fileVersionWithPrismaPredecessorSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaPredecessorSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaPredecessorSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaPredecessorSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaPredecessorSetParam) predecessorField() {}

type FileVersionWithPrismaPredecessorWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	predecessorField()
}

type fileVersionWithPrismaPredecessorEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaPredecessorEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaPredecessorEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaPredecessorEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaPredecessorEqualsParam) predecessorField() {}

func (fileVersionWithPrismaPredecessorSetParam) settable()  {}
func (fileVersionWithPrismaPredecessorEqualsParam) equals() {}

type fileVersionWithPrismaPredecessorEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaPredecessorEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaPredecessorEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaPredecessorEqualsUniqueParam) fileVersionModel() {}
func (p fileVersionWithPrismaPredecessorEqualsUniqueParam) predecessorField() {}

func (fileVersionWithPrismaPredecessorEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaPredecessorEqualsUniqueParam) equals() {}

type FileVersionWithPrismaPredecessorIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	fileVersionModel()
	predecessorIDField()
}

type FileVersionWithPrismaPredecessorIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	predecessorIDField()
}

type fileVersionWithPrismaPredecessorIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaPredecessorIDSetParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaPredecessorIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaPredecessorIDSetParam) fileVersionModel() {}

func (p fileVersionWithPrismaPredecessorIDSetParam) predecessorIDField() {}

type FileVersionWithPrismaPredecessorIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	fileVersionModel()
	predecessorIDField()
}

type fileVersionWithPrismaPredecessorIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaPredecessorIDEqualsParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaPredecessorIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaPredecessorIDEqualsParam) fileVersionModel() {}

func (p fileVersionWithPrismaPredecessorIDEqualsParam) predecessorIDField() {}

func (fileVersionWithPrismaPredecessorIDSetParam) settable()  {}
func (fileVersionWithPrismaPredecessorIDEqualsParam) equals() {}

type fileVersionWithPrismaPredecessorIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p fileVersionWithPrismaPredecessorIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p fileVersionWithPrismaPredecessorIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p fileVersionWithPrismaPredecessorIDEqualsUniqueParam) fileVersionModel()   {}
func (p fileVersionWithPrismaPredecessorIDEqualsUniqueParam) predecessorIDField() {}

func (fileVersionWithPrismaPredecessorIDEqualsUniqueParam) unique() {}
func (fileVersionWithPrismaPredecessorIDEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single dotfile.
func (r dotfileActions) CreateOne(
	_name DotfileWithPrismaNameSetParam,
	_path DotfileWithPrismaPathSetParam,
	_extension DotfileWithPrismaExtensionSetParam,
	_mimeType DotfileWithPrismaMimeTypeSetParam,
	_language DotfileWithPrismaLanguageSetParam,

	optional ...DotfileSetParam,
) dotfileCreateOne {
	var v dotfileCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Dotfile"
	v.query.Outputs = dotfileOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _path.field())
	fields = append(fields, _extension.field())
	fields = append(fields, _mimeType.field())
	fields = append(fields, _language.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r dotfileCreateOne) With(params ...iDotfileRelationWith) dotfileCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type dotfileCreateOne struct {
	query builder.Query
}

func (p dotfileCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p dotfileCreateOne) dotfileModel() {}

func (r dotfileCreateOne) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileCreateOne) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single fileVersion.
func (r fileVersionActions) CreateOne(
	_content FileVersionWithPrismaContentSetParam,
	_hash FileVersionWithPrismaHashSetParam,
	_file FileVersionWithPrismaFileSetParam,

	optional ...FileVersionSetParam,
) fileVersionCreateOne {
	var v fileVersionCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "FileVersion"
	v.query.Outputs = fileVersionOutput

	var fields []builder.Field

	fields = append(fields, _content.field())
	fields = append(fields, _hash.field())
	fields = append(fields, _file.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r fileVersionCreateOne) With(params ...iFileVersionRelationWith) fileVersionCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type fileVersionCreateOne struct {
	query builder.Query
}

func (p fileVersionCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p fileVersionCreateOne) fileVersionModel() {}

func (r fileVersionCreateOne) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionCreateOne) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type dotfileToCurrentFindUnique struct {
	query builder.Query
}

func (r dotfileToCurrentFindUnique) getQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentFindUnique) with()            {}
func (r dotfileToCurrentFindUnique) dotfileModel()    {}
func (r dotfileToCurrentFindUnique) dotfileRelation() {}

func (r dotfileToCurrentFindUnique) With(params ...iFileVersionRelationWith) dotfileToCurrentFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileToCurrentFindUnique) Exec(ctx context.Context) (
	*DotfileModel,
	error,
) {
	var v *DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileToCurrentFindUnique) ExecInner(ctx context.Context) (
	*InnerDotfile,
	error,
) {
	var v *InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileToCurrentFindUnique) Update(params ...DotfileSetParam) dotfileToCurrentUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Dotfile"

	var v dotfileToCurrentUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type dotfileToCurrentUpdateUnique struct {
	query builder.Query
}

func (r dotfileToCurrentUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentUpdateUnique) dotfileModel() {}

func (r dotfileToCurrentUpdateUnique) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToCurrentUpdateUnique) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r dotfileToCurrentFindUnique) Delete() dotfileToCurrentDeleteUnique {
	var v dotfileToCurrentDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Dotfile"

	return v
}

type dotfileToCurrentDeleteUnique struct {
	query builder.Query
}

func (r dotfileToCurrentDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p dotfileToCurrentDeleteUnique) dotfileModel() {}

func (r dotfileToCurrentDeleteUnique) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToCurrentDeleteUnique) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type dotfileToCurrentFindFirst struct {
	query builder.Query
}

func (r dotfileToCurrentFindFirst) getQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentFindFirst) with()            {}
func (r dotfileToCurrentFindFirst) dotfileModel()    {}
func (r dotfileToCurrentFindFirst) dotfileRelation() {}

func (r dotfileToCurrentFindFirst) With(params ...iFileVersionRelationWith) dotfileToCurrentFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileToCurrentFindFirst) OrderBy(params ...iFileVersionOrderByParam) dotfileToCurrentFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r dotfileToCurrentFindFirst) Skip(count int) dotfileToCurrentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r dotfileToCurrentFindFirst) Take(count int) dotfileToCurrentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r dotfileToCurrentFindFirst) Cursor(cursor iDotfileCursorParam) dotfileToCurrentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r dotfileToCurrentFindFirst) Exec(ctx context.Context) (
	*DotfileModel,
	error,
) {
	var v *DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileToCurrentFindFirst) ExecInner(ctx context.Context) (
	*InnerDotfile,
	error,
) {
	var v *InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type dotfileToCurrentFindMany struct {
	query builder.Query
}

func (r dotfileToCurrentFindMany) getQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentFindMany) with()            {}
func (r dotfileToCurrentFindMany) dotfileModel()    {}
func (r dotfileToCurrentFindMany) dotfileRelation() {}

func (r dotfileToCurrentFindMany) With(params ...iFileVersionRelationWith) dotfileToCurrentFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileToCurrentFindMany) OrderBy(params ...iFileVersionOrderByParam) dotfileToCurrentFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r dotfileToCurrentFindMany) Skip(count int) dotfileToCurrentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r dotfileToCurrentFindMany) Take(count int) dotfileToCurrentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r dotfileToCurrentFindMany) Cursor(cursor iDotfileCursorParam) dotfileToCurrentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r dotfileToCurrentFindMany) Exec(ctx context.Context) (
	[]DotfileModel,
	error,
) {
	var v []DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r dotfileToCurrentFindMany) ExecInner(ctx context.Context) (
	[]InnerDotfile,
	error,
) {
	var v []InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r dotfileToCurrentFindMany) Update(params ...DotfileSetParam) dotfileToCurrentUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Dotfile"

	r.query.Outputs = countOutput

	var v dotfileToCurrentUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type dotfileToCurrentUpdateMany struct {
	query builder.Query
}

func (r dotfileToCurrentUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToCurrentUpdateMany) dotfileModel() {}

func (r dotfileToCurrentUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToCurrentUpdateMany) Tx() dotfileManyTxResult {
	v := NewdotfileManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r dotfileToCurrentFindMany) Delete() dotfileToCurrentDeleteMany {
	var v dotfileToCurrentDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Dotfile"

	v.query.Outputs = countOutput

	return v
}

type dotfileToCurrentDeleteMany struct {
	query builder.Query
}

func (r dotfileToCurrentDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p dotfileToCurrentDeleteMany) dotfileModel() {}

func (r dotfileToCurrentDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToCurrentDeleteMany) Tx() dotfileManyTxResult {
	v := NewdotfileManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type dotfileToVersionsFindUnique struct {
	query builder.Query
}

func (r dotfileToVersionsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsFindUnique) with()            {}
func (r dotfileToVersionsFindUnique) dotfileModel()    {}
func (r dotfileToVersionsFindUnique) dotfileRelation() {}

func (r dotfileToVersionsFindUnique) With(params ...iFileVersionRelationWith) dotfileToVersionsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileToVersionsFindUnique) Exec(ctx context.Context) (
	*DotfileModel,
	error,
) {
	var v *DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileToVersionsFindUnique) ExecInner(ctx context.Context) (
	*InnerDotfile,
	error,
) {
	var v *InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileToVersionsFindUnique) Update(params ...DotfileSetParam) dotfileToVersionsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Dotfile"

	var v dotfileToVersionsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type dotfileToVersionsUpdateUnique struct {
	query builder.Query
}

func (r dotfileToVersionsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsUpdateUnique) dotfileModel() {}

func (r dotfileToVersionsUpdateUnique) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToVersionsUpdateUnique) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r dotfileToVersionsFindUnique) Delete() dotfileToVersionsDeleteUnique {
	var v dotfileToVersionsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Dotfile"

	return v
}

type dotfileToVersionsDeleteUnique struct {
	query builder.Query
}

func (r dotfileToVersionsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p dotfileToVersionsDeleteUnique) dotfileModel() {}

func (r dotfileToVersionsDeleteUnique) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToVersionsDeleteUnique) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type dotfileToVersionsFindFirst struct {
	query builder.Query
}

func (r dotfileToVersionsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsFindFirst) with()            {}
func (r dotfileToVersionsFindFirst) dotfileModel()    {}
func (r dotfileToVersionsFindFirst) dotfileRelation() {}

func (r dotfileToVersionsFindFirst) With(params ...iFileVersionRelationWith) dotfileToVersionsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileToVersionsFindFirst) OrderBy(params ...iFileVersionOrderByParam) dotfileToVersionsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r dotfileToVersionsFindFirst) Skip(count int) dotfileToVersionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r dotfileToVersionsFindFirst) Take(count int) dotfileToVersionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r dotfileToVersionsFindFirst) Cursor(cursor iDotfileCursorParam) dotfileToVersionsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r dotfileToVersionsFindFirst) Exec(ctx context.Context) (
	*DotfileModel,
	error,
) {
	var v *DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileToVersionsFindFirst) ExecInner(ctx context.Context) (
	*InnerDotfile,
	error,
) {
	var v *InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type dotfileToVersionsFindMany struct {
	query builder.Query
}

func (r dotfileToVersionsFindMany) getQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsFindMany) with()            {}
func (r dotfileToVersionsFindMany) dotfileModel()    {}
func (r dotfileToVersionsFindMany) dotfileRelation() {}

func (r dotfileToVersionsFindMany) With(params ...iFileVersionRelationWith) dotfileToVersionsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileToVersionsFindMany) OrderBy(params ...iFileVersionOrderByParam) dotfileToVersionsFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r dotfileToVersionsFindMany) Skip(count int) dotfileToVersionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r dotfileToVersionsFindMany) Take(count int) dotfileToVersionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r dotfileToVersionsFindMany) Cursor(cursor iDotfileCursorParam) dotfileToVersionsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r dotfileToVersionsFindMany) Exec(ctx context.Context) (
	[]DotfileModel,
	error,
) {
	var v []DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r dotfileToVersionsFindMany) ExecInner(ctx context.Context) (
	[]InnerDotfile,
	error,
) {
	var v []InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r dotfileToVersionsFindMany) Update(params ...DotfileSetParam) dotfileToVersionsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Dotfile"

	r.query.Outputs = countOutput

	var v dotfileToVersionsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type dotfileToVersionsUpdateMany struct {
	query builder.Query
}

func (r dotfileToVersionsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileToVersionsUpdateMany) dotfileModel() {}

func (r dotfileToVersionsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToVersionsUpdateMany) Tx() dotfileManyTxResult {
	v := NewdotfileManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r dotfileToVersionsFindMany) Delete() dotfileToVersionsDeleteMany {
	var v dotfileToVersionsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Dotfile"

	v.query.Outputs = countOutput

	return v
}

type dotfileToVersionsDeleteMany struct {
	query builder.Query
}

func (r dotfileToVersionsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p dotfileToVersionsDeleteMany) dotfileModel() {}

func (r dotfileToVersionsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileToVersionsDeleteMany) Tx() dotfileManyTxResult {
	v := NewdotfileManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type dotfileFindUnique struct {
	query builder.Query
}

func (r dotfileFindUnique) getQuery() builder.Query {
	return r.query
}

func (r dotfileFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileFindUnique) with()            {}
func (r dotfileFindUnique) dotfileModel()    {}
func (r dotfileFindUnique) dotfileRelation() {}

func (r dotfileActions) FindUnique(
	params DotfileEqualsUniqueWhereParam,
) dotfileFindUnique {
	var v dotfileFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Dotfile"
	v.query.Outputs = dotfileOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r dotfileFindUnique) With(params ...iDotfileRelationWith) dotfileFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileFindUnique) Exec(ctx context.Context) (
	*DotfileModel,
	error,
) {
	var v *DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileFindUnique) ExecInner(ctx context.Context) (
	*InnerDotfile,
	error,
) {
	var v *InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileFindUnique) Update(params ...DotfileSetParam) dotfileUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Dotfile"

	var v dotfileUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type dotfileUpdateUnique struct {
	query builder.Query
}

func (r dotfileUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileUpdateUnique) dotfileModel() {}

func (r dotfileUpdateUnique) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileUpdateUnique) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r dotfileFindUnique) Delete() dotfileDeleteUnique {
	var v dotfileDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Dotfile"

	return v
}

type dotfileDeleteUnique struct {
	query builder.Query
}

func (r dotfileDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p dotfileDeleteUnique) dotfileModel() {}

func (r dotfileDeleteUnique) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileDeleteUnique) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type dotfileFindFirst struct {
	query builder.Query
}

func (r dotfileFindFirst) getQuery() builder.Query {
	return r.query
}

func (r dotfileFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileFindFirst) with()            {}
func (r dotfileFindFirst) dotfileModel()    {}
func (r dotfileFindFirst) dotfileRelation() {}

func (r dotfileActions) FindFirst(
	params ...DotfileWhereParam,
) dotfileFindFirst {
	var v dotfileFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Dotfile"
	v.query.Outputs = dotfileOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{builder.Field{
				Name:     "AND",
				List:     true,
				WrapList: true,
				Fields:   where,
			}},
		})
	}

	return v
}

func (r dotfileFindFirst) With(params ...iDotfileRelationWith) dotfileFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileFindFirst) OrderBy(params ...iDotfileOrderByParam) dotfileFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r dotfileFindFirst) Skip(count int) dotfileFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r dotfileFindFirst) Take(count int) dotfileFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r dotfileFindFirst) Cursor(cursor iDotfileCursorParam) dotfileFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r dotfileFindFirst) Exec(ctx context.Context) (
	*DotfileModel,
	error,
) {
	var v *DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r dotfileFindFirst) ExecInner(ctx context.Context) (
	*InnerDotfile,
	error,
) {
	var v *InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type dotfileFindMany struct {
	query builder.Query
}

func (r dotfileFindMany) getQuery() builder.Query {
	return r.query
}

func (r dotfileFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileFindMany) with()            {}
func (r dotfileFindMany) dotfileModel()    {}
func (r dotfileFindMany) dotfileRelation() {}

func (r dotfileActions) FindMany(
	params ...DotfileWhereParam,
) dotfileFindMany {
	var v dotfileFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Dotfile"
	v.query.Outputs = dotfileOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{builder.Field{
				Name:     "AND",
				List:     true,
				WrapList: true,
				Fields:   where,
			}},
		})
	}

	return v
}

func (r dotfileFindMany) With(params ...iDotfileRelationWith) dotfileFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r dotfileFindMany) OrderBy(params ...iDotfileOrderByParam) dotfileFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r dotfileFindMany) Skip(count int) dotfileFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r dotfileFindMany) Take(count int) dotfileFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r dotfileFindMany) Cursor(cursor iDotfileCursorParam) dotfileFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r dotfileFindMany) Exec(ctx context.Context) (
	[]DotfileModel,
	error,
) {
	var v []DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r dotfileFindMany) ExecInner(ctx context.Context) (
	[]InnerDotfile,
	error,
) {
	var v []InnerDotfile
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r dotfileFindMany) Update(params ...DotfileSetParam) dotfileUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Dotfile"

	r.query.Outputs = countOutput

	var v dotfileUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type dotfileUpdateMany struct {
	query builder.Query
}

func (r dotfileUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileUpdateMany) dotfileModel() {}

func (r dotfileUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileUpdateMany) Tx() dotfileManyTxResult {
	v := NewdotfileManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r dotfileFindMany) Delete() dotfileDeleteMany {
	var v dotfileDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Dotfile"

	v.query.Outputs = countOutput

	return v
}

type dotfileDeleteMany struct {
	query builder.Query
}

func (r dotfileDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p dotfileDeleteMany) dotfileModel() {}

func (r dotfileDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileDeleteMany) Tx() dotfileManyTxResult {
	v := NewdotfileManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToCurrentlyUsedFindUnique struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedFindUnique) with()                {}
func (r fileVersionToCurrentlyUsedFindUnique) fileVersionModel()    {}
func (r fileVersionToCurrentlyUsedFindUnique) fileVersionRelation() {}

func (r fileVersionToCurrentlyUsedFindUnique) With(params ...iDotfileRelationWith) fileVersionToCurrentlyUsedFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToCurrentlyUsedFindUnique) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToCurrentlyUsedFindUnique) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToCurrentlyUsedFindUnique) Update(params ...FileVersionSetParam) fileVersionToCurrentlyUsedUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "FileVersion"

	var v fileVersionToCurrentlyUsedUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToCurrentlyUsedUpdateUnique struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedUpdateUnique) fileVersionModel() {}

func (r fileVersionToCurrentlyUsedUpdateUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToCurrentlyUsedUpdateUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToCurrentlyUsedFindUnique) Delete() fileVersionToCurrentlyUsedDeleteUnique {
	var v fileVersionToCurrentlyUsedDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "FileVersion"

	return v
}

type fileVersionToCurrentlyUsedDeleteUnique struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToCurrentlyUsedDeleteUnique) fileVersionModel() {}

func (r fileVersionToCurrentlyUsedDeleteUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToCurrentlyUsedDeleteUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToCurrentlyUsedFindFirst struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedFindFirst) with()                {}
func (r fileVersionToCurrentlyUsedFindFirst) fileVersionModel()    {}
func (r fileVersionToCurrentlyUsedFindFirst) fileVersionRelation() {}

func (r fileVersionToCurrentlyUsedFindFirst) With(params ...iDotfileRelationWith) fileVersionToCurrentlyUsedFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToCurrentlyUsedFindFirst) OrderBy(params ...iDotfileOrderByParam) fileVersionToCurrentlyUsedFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToCurrentlyUsedFindFirst) Skip(count int) fileVersionToCurrentlyUsedFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToCurrentlyUsedFindFirst) Take(count int) fileVersionToCurrentlyUsedFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToCurrentlyUsedFindFirst) Cursor(cursor iFileVersionCursorParam) fileVersionToCurrentlyUsedFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToCurrentlyUsedFindFirst) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToCurrentlyUsedFindFirst) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fileVersionToCurrentlyUsedFindMany struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedFindMany) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedFindMany) with()                {}
func (r fileVersionToCurrentlyUsedFindMany) fileVersionModel()    {}
func (r fileVersionToCurrentlyUsedFindMany) fileVersionRelation() {}

func (r fileVersionToCurrentlyUsedFindMany) With(params ...iDotfileRelationWith) fileVersionToCurrentlyUsedFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToCurrentlyUsedFindMany) OrderBy(params ...iDotfileOrderByParam) fileVersionToCurrentlyUsedFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToCurrentlyUsedFindMany) Skip(count int) fileVersionToCurrentlyUsedFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToCurrentlyUsedFindMany) Take(count int) fileVersionToCurrentlyUsedFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToCurrentlyUsedFindMany) Cursor(cursor iFileVersionCursorParam) fileVersionToCurrentlyUsedFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToCurrentlyUsedFindMany) Exec(ctx context.Context) (
	[]FileVersionModel,
	error,
) {
	var v []FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToCurrentlyUsedFindMany) ExecInner(ctx context.Context) (
	[]InnerFileVersion,
	error,
) {
	var v []InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToCurrentlyUsedFindMany) Update(params ...FileVersionSetParam) fileVersionToCurrentlyUsedUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "FileVersion"

	r.query.Outputs = countOutput

	var v fileVersionToCurrentlyUsedUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToCurrentlyUsedUpdateMany struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToCurrentlyUsedUpdateMany) fileVersionModel() {}

func (r fileVersionToCurrentlyUsedUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToCurrentlyUsedUpdateMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToCurrentlyUsedFindMany) Delete() fileVersionToCurrentlyUsedDeleteMany {
	var v fileVersionToCurrentlyUsedDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "FileVersion"

	v.query.Outputs = countOutput

	return v
}

type fileVersionToCurrentlyUsedDeleteMany struct {
	query builder.Query
}

func (r fileVersionToCurrentlyUsedDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToCurrentlyUsedDeleteMany) fileVersionModel() {}

func (r fileVersionToCurrentlyUsedDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToCurrentlyUsedDeleteMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToFileFindUnique struct {
	query builder.Query
}

func (r fileVersionToFileFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileFindUnique) with()                {}
func (r fileVersionToFileFindUnique) fileVersionModel()    {}
func (r fileVersionToFileFindUnique) fileVersionRelation() {}

func (r fileVersionToFileFindUnique) With(params ...iDotfileRelationWith) fileVersionToFileFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToFileFindUnique) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToFileFindUnique) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToFileFindUnique) Update(params ...FileVersionSetParam) fileVersionToFileUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "FileVersion"

	var v fileVersionToFileUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToFileUpdateUnique struct {
	query builder.Query
}

func (r fileVersionToFileUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileUpdateUnique) fileVersionModel() {}

func (r fileVersionToFileUpdateUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToFileUpdateUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToFileFindUnique) Delete() fileVersionToFileDeleteUnique {
	var v fileVersionToFileDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "FileVersion"

	return v
}

type fileVersionToFileDeleteUnique struct {
	query builder.Query
}

func (r fileVersionToFileDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToFileDeleteUnique) fileVersionModel() {}

func (r fileVersionToFileDeleteUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToFileDeleteUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToFileFindFirst struct {
	query builder.Query
}

func (r fileVersionToFileFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileFindFirst) with()                {}
func (r fileVersionToFileFindFirst) fileVersionModel()    {}
func (r fileVersionToFileFindFirst) fileVersionRelation() {}

func (r fileVersionToFileFindFirst) With(params ...iDotfileRelationWith) fileVersionToFileFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToFileFindFirst) OrderBy(params ...iDotfileOrderByParam) fileVersionToFileFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToFileFindFirst) Skip(count int) fileVersionToFileFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToFileFindFirst) Take(count int) fileVersionToFileFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToFileFindFirst) Cursor(cursor iFileVersionCursorParam) fileVersionToFileFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToFileFindFirst) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToFileFindFirst) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fileVersionToFileFindMany struct {
	query builder.Query
}

func (r fileVersionToFileFindMany) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileFindMany) with()                {}
func (r fileVersionToFileFindMany) fileVersionModel()    {}
func (r fileVersionToFileFindMany) fileVersionRelation() {}

func (r fileVersionToFileFindMany) With(params ...iDotfileRelationWith) fileVersionToFileFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToFileFindMany) OrderBy(params ...iDotfileOrderByParam) fileVersionToFileFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToFileFindMany) Skip(count int) fileVersionToFileFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToFileFindMany) Take(count int) fileVersionToFileFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToFileFindMany) Cursor(cursor iFileVersionCursorParam) fileVersionToFileFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToFileFindMany) Exec(ctx context.Context) (
	[]FileVersionModel,
	error,
) {
	var v []FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToFileFindMany) ExecInner(ctx context.Context) (
	[]InnerFileVersion,
	error,
) {
	var v []InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToFileFindMany) Update(params ...FileVersionSetParam) fileVersionToFileUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "FileVersion"

	r.query.Outputs = countOutput

	var v fileVersionToFileUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToFileUpdateMany struct {
	query builder.Query
}

func (r fileVersionToFileUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToFileUpdateMany) fileVersionModel() {}

func (r fileVersionToFileUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToFileUpdateMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToFileFindMany) Delete() fileVersionToFileDeleteMany {
	var v fileVersionToFileDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "FileVersion"

	v.query.Outputs = countOutput

	return v
}

type fileVersionToFileDeleteMany struct {
	query builder.Query
}

func (r fileVersionToFileDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToFileDeleteMany) fileVersionModel() {}

func (r fileVersionToFileDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToFileDeleteMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToSuccessorFindUnique struct {
	query builder.Query
}

func (r fileVersionToSuccessorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorFindUnique) with()                {}
func (r fileVersionToSuccessorFindUnique) fileVersionModel()    {}
func (r fileVersionToSuccessorFindUnique) fileVersionRelation() {}

func (r fileVersionToSuccessorFindUnique) With(params ...iFileVersionRelationWith) fileVersionToSuccessorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToSuccessorFindUnique) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToSuccessorFindUnique) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToSuccessorFindUnique) Update(params ...FileVersionSetParam) fileVersionToSuccessorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "FileVersion"

	var v fileVersionToSuccessorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToSuccessorUpdateUnique struct {
	query builder.Query
}

func (r fileVersionToSuccessorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorUpdateUnique) fileVersionModel() {}

func (r fileVersionToSuccessorUpdateUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToSuccessorUpdateUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToSuccessorFindUnique) Delete() fileVersionToSuccessorDeleteUnique {
	var v fileVersionToSuccessorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "FileVersion"

	return v
}

type fileVersionToSuccessorDeleteUnique struct {
	query builder.Query
}

func (r fileVersionToSuccessorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToSuccessorDeleteUnique) fileVersionModel() {}

func (r fileVersionToSuccessorDeleteUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToSuccessorDeleteUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToSuccessorFindFirst struct {
	query builder.Query
}

func (r fileVersionToSuccessorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorFindFirst) with()                {}
func (r fileVersionToSuccessorFindFirst) fileVersionModel()    {}
func (r fileVersionToSuccessorFindFirst) fileVersionRelation() {}

func (r fileVersionToSuccessorFindFirst) With(params ...iFileVersionRelationWith) fileVersionToSuccessorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToSuccessorFindFirst) OrderBy(params ...iFileVersionOrderByParam) fileVersionToSuccessorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToSuccessorFindFirst) Skip(count int) fileVersionToSuccessorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToSuccessorFindFirst) Take(count int) fileVersionToSuccessorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToSuccessorFindFirst) Cursor(cursor iFileVersionCursorParam) fileVersionToSuccessorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToSuccessorFindFirst) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToSuccessorFindFirst) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fileVersionToSuccessorFindMany struct {
	query builder.Query
}

func (r fileVersionToSuccessorFindMany) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorFindMany) with()                {}
func (r fileVersionToSuccessorFindMany) fileVersionModel()    {}
func (r fileVersionToSuccessorFindMany) fileVersionRelation() {}

func (r fileVersionToSuccessorFindMany) With(params ...iFileVersionRelationWith) fileVersionToSuccessorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToSuccessorFindMany) OrderBy(params ...iFileVersionOrderByParam) fileVersionToSuccessorFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToSuccessorFindMany) Skip(count int) fileVersionToSuccessorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToSuccessorFindMany) Take(count int) fileVersionToSuccessorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToSuccessorFindMany) Cursor(cursor iFileVersionCursorParam) fileVersionToSuccessorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToSuccessorFindMany) Exec(ctx context.Context) (
	[]FileVersionModel,
	error,
) {
	var v []FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToSuccessorFindMany) ExecInner(ctx context.Context) (
	[]InnerFileVersion,
	error,
) {
	var v []InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToSuccessorFindMany) Update(params ...FileVersionSetParam) fileVersionToSuccessorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "FileVersion"

	r.query.Outputs = countOutput

	var v fileVersionToSuccessorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToSuccessorUpdateMany struct {
	query builder.Query
}

func (r fileVersionToSuccessorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToSuccessorUpdateMany) fileVersionModel() {}

func (r fileVersionToSuccessorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToSuccessorUpdateMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToSuccessorFindMany) Delete() fileVersionToSuccessorDeleteMany {
	var v fileVersionToSuccessorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "FileVersion"

	v.query.Outputs = countOutput

	return v
}

type fileVersionToSuccessorDeleteMany struct {
	query builder.Query
}

func (r fileVersionToSuccessorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToSuccessorDeleteMany) fileVersionModel() {}

func (r fileVersionToSuccessorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToSuccessorDeleteMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToPredecessorFindUnique struct {
	query builder.Query
}

func (r fileVersionToPredecessorFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorFindUnique) with()                {}
func (r fileVersionToPredecessorFindUnique) fileVersionModel()    {}
func (r fileVersionToPredecessorFindUnique) fileVersionRelation() {}

func (r fileVersionToPredecessorFindUnique) With(params ...iFileVersionRelationWith) fileVersionToPredecessorFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToPredecessorFindUnique) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToPredecessorFindUnique) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToPredecessorFindUnique) Update(params ...FileVersionSetParam) fileVersionToPredecessorUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "FileVersion"

	var v fileVersionToPredecessorUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToPredecessorUpdateUnique struct {
	query builder.Query
}

func (r fileVersionToPredecessorUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorUpdateUnique) fileVersionModel() {}

func (r fileVersionToPredecessorUpdateUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToPredecessorUpdateUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToPredecessorFindUnique) Delete() fileVersionToPredecessorDeleteUnique {
	var v fileVersionToPredecessorDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "FileVersion"

	return v
}

type fileVersionToPredecessorDeleteUnique struct {
	query builder.Query
}

func (r fileVersionToPredecessorDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToPredecessorDeleteUnique) fileVersionModel() {}

func (r fileVersionToPredecessorDeleteUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToPredecessorDeleteUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionToPredecessorFindFirst struct {
	query builder.Query
}

func (r fileVersionToPredecessorFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorFindFirst) with()                {}
func (r fileVersionToPredecessorFindFirst) fileVersionModel()    {}
func (r fileVersionToPredecessorFindFirst) fileVersionRelation() {}

func (r fileVersionToPredecessorFindFirst) With(params ...iFileVersionRelationWith) fileVersionToPredecessorFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToPredecessorFindFirst) OrderBy(params ...iFileVersionOrderByParam) fileVersionToPredecessorFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToPredecessorFindFirst) Skip(count int) fileVersionToPredecessorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToPredecessorFindFirst) Take(count int) fileVersionToPredecessorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToPredecessorFindFirst) Cursor(cursor iFileVersionCursorParam) fileVersionToPredecessorFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToPredecessorFindFirst) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionToPredecessorFindFirst) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fileVersionToPredecessorFindMany struct {
	query builder.Query
}

func (r fileVersionToPredecessorFindMany) getQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorFindMany) with()                {}
func (r fileVersionToPredecessorFindMany) fileVersionModel()    {}
func (r fileVersionToPredecessorFindMany) fileVersionRelation() {}

func (r fileVersionToPredecessorFindMany) With(params ...iFileVersionRelationWith) fileVersionToPredecessorFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionToPredecessorFindMany) OrderBy(params ...iFileVersionOrderByParam) fileVersionToPredecessorFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionToPredecessorFindMany) Skip(count int) fileVersionToPredecessorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionToPredecessorFindMany) Take(count int) fileVersionToPredecessorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionToPredecessorFindMany) Cursor(cursor iFileVersionCursorParam) fileVersionToPredecessorFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionToPredecessorFindMany) Exec(ctx context.Context) (
	[]FileVersionModel,
	error,
) {
	var v []FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToPredecessorFindMany) ExecInner(ctx context.Context) (
	[]InnerFileVersion,
	error,
) {
	var v []InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionToPredecessorFindMany) Update(params ...FileVersionSetParam) fileVersionToPredecessorUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "FileVersion"

	r.query.Outputs = countOutput

	var v fileVersionToPredecessorUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionToPredecessorUpdateMany struct {
	query builder.Query
}

func (r fileVersionToPredecessorUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionToPredecessorUpdateMany) fileVersionModel() {}

func (r fileVersionToPredecessorUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToPredecessorUpdateMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionToPredecessorFindMany) Delete() fileVersionToPredecessorDeleteMany {
	var v fileVersionToPredecessorDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "FileVersion"

	v.query.Outputs = countOutput

	return v
}

type fileVersionToPredecessorDeleteMany struct {
	query builder.Query
}

func (r fileVersionToPredecessorDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionToPredecessorDeleteMany) fileVersionModel() {}

func (r fileVersionToPredecessorDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionToPredecessorDeleteMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionFindUnique struct {
	query builder.Query
}

func (r fileVersionFindUnique) getQuery() builder.Query {
	return r.query
}

func (r fileVersionFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionFindUnique) with()                {}
func (r fileVersionFindUnique) fileVersionModel()    {}
func (r fileVersionFindUnique) fileVersionRelation() {}

func (r fileVersionActions) FindUnique(
	params FileVersionEqualsUniqueWhereParam,
) fileVersionFindUnique {
	var v fileVersionFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "FileVersion"
	v.query.Outputs = fileVersionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r fileVersionFindUnique) With(params ...iFileVersionRelationWith) fileVersionFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionFindUnique) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionFindUnique) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionFindUnique) Update(params ...FileVersionSetParam) fileVersionUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "FileVersion"

	var v fileVersionUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionUpdateUnique struct {
	query builder.Query
}

func (r fileVersionUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionUpdateUnique) fileVersionModel() {}

func (r fileVersionUpdateUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionUpdateUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionFindUnique) Delete() fileVersionDeleteUnique {
	var v fileVersionDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "FileVersion"

	return v
}

type fileVersionDeleteUnique struct {
	query builder.Query
}

func (r fileVersionDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionDeleteUnique) fileVersionModel() {}

func (r fileVersionDeleteUnique) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionDeleteUnique) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionFindFirst struct {
	query builder.Query
}

func (r fileVersionFindFirst) getQuery() builder.Query {
	return r.query
}

func (r fileVersionFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionFindFirst) with()                {}
func (r fileVersionFindFirst) fileVersionModel()    {}
func (r fileVersionFindFirst) fileVersionRelation() {}

func (r fileVersionActions) FindFirst(
	params ...FileVersionWhereParam,
) fileVersionFindFirst {
	var v fileVersionFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "FileVersion"
	v.query.Outputs = fileVersionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{builder.Field{
				Name:     "AND",
				List:     true,
				WrapList: true,
				Fields:   where,
			}},
		})
	}

	return v
}

func (r fileVersionFindFirst) With(params ...iFileVersionRelationWith) fileVersionFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionFindFirst) OrderBy(params ...iFileVersionOrderByParam) fileVersionFindFirst {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionFindFirst) Skip(count int) fileVersionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionFindFirst) Take(count int) fileVersionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionFindFirst) Cursor(cursor iFileVersionCursorParam) fileVersionFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionFindFirst) Exec(ctx context.Context) (
	*FileVersionModel,
	error,
) {
	var v *FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r fileVersionFindFirst) ExecInner(ctx context.Context) (
	*InnerFileVersion,
	error,
) {
	var v *InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type fileVersionFindMany struct {
	query builder.Query
}

func (r fileVersionFindMany) getQuery() builder.Query {
	return r.query
}

func (r fileVersionFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionFindMany) with()                {}
func (r fileVersionFindMany) fileVersionModel()    {}
func (r fileVersionFindMany) fileVersionRelation() {}

func (r fileVersionActions) FindMany(
	params ...FileVersionWhereParam,
) fileVersionFindMany {
	var v fileVersionFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "FileVersion"
	v.query.Outputs = fileVersionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{builder.Field{
				Name:     "AND",
				List:     true,
				WrapList: true,
				Fields:   where,
			}},
		})
	}

	return v
}

func (r fileVersionFindMany) With(params ...iFileVersionRelationWith) fileVersionFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r fileVersionFindMany) OrderBy(params ...iFileVersionOrderByParam) fileVersionFindMany {
	var fields []builder.Field

	for _, param := range params {
		direction, _ := param.field().Value.(types.Direction)

		fields = append(fields, builder.Field{
			Name:  param.field().Name,
			Value: direction,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "orderBy",
		Fields: fields,
	})

	return r
}

func (r fileVersionFindMany) Skip(count int) fileVersionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r fileVersionFindMany) Take(count int) fileVersionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r fileVersionFindMany) Cursor(cursor iFileVersionCursorParam) fileVersionFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r fileVersionFindMany) Exec(ctx context.Context) (
	[]FileVersionModel,
	error,
) {
	var v []FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionFindMany) ExecInner(ctx context.Context) (
	[]InnerFileVersion,
	error,
) {
	var v []InnerFileVersion
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r fileVersionFindMany) Update(params ...FileVersionSetParam) fileVersionUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "FileVersion"

	r.query.Outputs = countOutput

	var v fileVersionUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type fileVersionUpdateMany struct {
	query builder.Query
}

func (r fileVersionUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionUpdateMany) fileVersionModel() {}

func (r fileVersionUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionUpdateMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r fileVersionFindMany) Delete() fileVersionDeleteMany {
	var v fileVersionDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "FileVersion"

	v.query.Outputs = countOutput

	return v
}

type fileVersionDeleteMany struct {
	query builder.Query
}

func (r fileVersionDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p fileVersionDeleteMany) fileVersionModel() {}

func (r fileVersionDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionDeleteMany) Tx() fileVersionManyTxResult {
	v := NewfileVersionManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func NewdotfileUniqueTxResult() dotfileUniqueTxResult {
	return dotfileUniqueTxResult{
		result: &transaction.Result{},
	}
}

type dotfileUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p dotfileUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p dotfileUniqueTxResult) IsTx() {}

func (r dotfileUniqueTxResult) Result() (v *DotfileModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewdotfileManyTxResult() dotfileManyTxResult {
	return dotfileManyTxResult{
		result: &transaction.Result{},
	}
}

type dotfileManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p dotfileManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p dotfileManyTxResult) IsTx() {}

func (r dotfileManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewfileVersionUniqueTxResult() fileVersionUniqueTxResult {
	return fileVersionUniqueTxResult{
		result: &transaction.Result{},
	}
}

type fileVersionUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p fileVersionUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p fileVersionUniqueTxResult) IsTx() {}

func (r fileVersionUniqueTxResult) Result() (v *FileVersionModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func NewfileVersionManyTxResult() fileVersionManyTxResult {
	return fileVersionManyTxResult{
		result: &transaction.Result{},
	}
}

type fileVersionManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p fileVersionManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p fileVersionManyTxResult) IsTx() {}

func (r fileVersionManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type dotfileUpsertOne struct {
	query builder.Query
}

func (r dotfileUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r dotfileUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r dotfileUpsertOne) with()            {}
func (r dotfileUpsertOne) dotfileModel()    {}
func (r dotfileUpsertOne) dotfileRelation() {}

func (r dotfileActions) UpsertOne(
	params DotfileEqualsUniqueWhereParam,
) dotfileUpsertOne {
	var v dotfileUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Dotfile"
	v.query.Outputs = dotfileOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r dotfileUpsertOne) Create(

	_name DotfileWithPrismaNameSetParam,
	_path DotfileWithPrismaPathSetParam,
	_extension DotfileWithPrismaExtensionSetParam,
	_mimeType DotfileWithPrismaMimeTypeSetParam,
	_language DotfileWithPrismaLanguageSetParam,

	optional ...DotfileSetParam,
) dotfileUpsertOne {
	var v dotfileUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _path.field())
	fields = append(fields, _extension.field())
	fields = append(fields, _mimeType.field())
	fields = append(fields, _language.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r dotfileUpsertOne) Update(
	params ...DotfileSetParam,
) dotfileUpsertOne {
	var v dotfileUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r dotfileUpsertOne) Exec(ctx context.Context) (*DotfileModel, error) {
	var v DotfileModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r dotfileUpsertOne) Tx() dotfileUniqueTxResult {
	v := NewdotfileUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type fileVersionUpsertOne struct {
	query builder.Query
}

func (r fileVersionUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r fileVersionUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r fileVersionUpsertOne) with()                {}
func (r fileVersionUpsertOne) fileVersionModel()    {}
func (r fileVersionUpsertOne) fileVersionRelation() {}

func (r fileVersionActions) UpsertOne(
	params FileVersionEqualsUniqueWhereParam,
) fileVersionUpsertOne {
	var v fileVersionUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "FileVersion"
	v.query.Outputs = fileVersionOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r fileVersionUpsertOne) Create(

	_content FileVersionWithPrismaContentSetParam,
	_hash FileVersionWithPrismaHashSetParam,
	_file FileVersionWithPrismaFileSetParam,

	optional ...FileVersionSetParam,
) fileVersionUpsertOne {
	var v fileVersionUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _content.field())
	fields = append(fields, _hash.field())
	fields = append(fields, _file.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r fileVersionUpsertOne) Update(
	params ...FileVersionSetParam,
) fileVersionUpsertOne {
	var v fileVersionUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r fileVersionUpsertOne) Exec(ctx context.Context) (*FileVersionModel, error) {
	var v FileVersionModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r fileVersionUpsertOne) Tx() fileVersionUniqueTxResult {
	v := NewfileVersionUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template client.gotpl ---
const schema = `generator client {
  provider = "prisma-client-go"
}

datasource db {
  provider = "sqlite"
  url      = "file:storage.db"
}

model Dotfile {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String
  path      String @unique // Cannot manage multiple files in the same location
  extension String
  mimeType  String
  language  String

  // Currently used file version
  current   FileVersion? @relation("CurrentVersion", fields: [currentId], references: [id])
  currentId String?

  // All versions of the file
  versions FileVersion[] @relation("Versions")
}

model FileVersion {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content String
  hash    String

  // Currently used by dotfile
  currentlyUsed Dotfile? @relation("CurrentVersion")

  // Dotfile this version belongs to
  file   Dotfile @relation("Versions", fields: [fileId], references: [id])
  fileId String

  // Previous version of this file
  successor     FileVersion[] @relation("PreviousFileVersion")
  predecessor   FileVersion?  @relation("PreviousFileVersion", fields: [predecessorId], references: [id])
  predecessorId String?

  // appliedSnippets Snippet[]
}

// model Snippet {
//   id        String   @id @default(cuid())
//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
//
//   appliedTo   FileVersion @relation(fields: [appliedToId], references: [id])
//   appliedToId String
//
//   language String
//   name     String
//   key      String
//   content  String
//
// }
`

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = false

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//   client := db.NewClient()
//   if err := client.Prisma.Connect(); err != nil {
//     handle(err)
//   }
//
//   defer func() {
//     if err := client.Prisma.Disconnect(); err != nil {
//       panic(fmt.Errorf("could not disconnect: %w", err))
//     }
//   }()
func NewClient() *PrismaClient {
	c := newClient()
	c.Engine = engine.New(schema, hasBinaryTargets)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.Dotfile = dotfileActions{client: c}
	c.FileVersion = fileVersionActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// Dotfile provides access to CRUD methods.
	Dotfile dotfileActions
	// FileVersion provides access to CRUD methods.
	FileVersion fileVersionActions
}

// deprecated: use .Prisma.Connect
func (c *PrismaClient) Connect() error {
	return c.Prisma.Connect()
}

// deprecated: use .Prisma.Disconnect
func (c *PrismaClient) Disconnect() error {
	return c.Prisma.Disconnect()
}

// deprecated: use .Prisma.QueryRaw
func (c *PrismaClient) QueryRaw(query string, params ...interface{}) raw.QueryExec {
	return c.Prisma.QueryRaw(query, params...)
}

// deprecated: use .Prisma.ExecuteRaw
func (c *PrismaClient) ExecuteRaw(query string, params ...interface{}) raw.ExecuteExec {
	return c.Prisma.ExecuteRaw(query, params...)
}

// --- template enums.gotpl ---

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.Dotfile = dotfileMock{
		mock: m,
	}

	m.FileVersion = fileVersionMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	Dotfile dotfileMock

	FileVersion fileVersionMock
}

type dotfileMock struct {
	mock *Mock
}

type iDotfileMockExpectParam interface {
	ExtractQuery() builder.Query
	dotfileModel()
}

func (m *dotfileMock) Expect(query iDotfileMockExpectParam) *dotfileMockExec {
	return &dotfileMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type dotfileMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *dotfileMockExec) Returns(v DotfileModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *dotfileMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type fileVersionMock struct {
	mock *Mock
}

type iFileVersionMockExpectParam interface {
	ExtractQuery() builder.Query
	fileVersionModel()
}

func (m *fileVersionMock) Expect(query iFileVersionMockExpectParam) *fileVersionMockExec {
	return &fileVersionMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type fileVersionMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *fileVersionMockExec) Returns(v FileVersionModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *fileVersionMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// DotfileModel represents the `json:"Dotfile"` model and is a wrapper for accessing fields and methods
type DotfileModel struct {
	InnerDotfile
	RelationsDotfile
}

// InnerDotfile holds the actual data
type InnerDotfile struct {
	ID        string   `json:"id"`
	CreatedAt DateTime `json:"createdAt"`
	UpdatedAt DateTime `json:"updatedAt"`
	Name      string   `json:"name"`
	Path      string   `json:"path"`
	Extension string   `json:"extension"`
	MimeType  string   `json:"mimeType"`
	Language  string   `json:"language"`
	CurrentID *string  `json:"currentId"`
}

// RelationsDotfile holds the relation data separately
type RelationsDotfile struct {
	Current  *FileVersionModel  `json:"current"`
	Versions []FileVersionModel `json:"versions"`
}

func (r DotfileModel) Current() (value *FileVersionModel, ok bool) {
	if r.RelationsDotfile.Current == nil {
		return value, false
	}
	return r.RelationsDotfile.Current, true
}

func (r DotfileModel) CurrentID() (value string, ok bool) {
	if r.InnerDotfile.CurrentID == nil {
		return value, false
	}
	return *r.InnerDotfile.CurrentID, true
}

func (r DotfileModel) Versions() (value []FileVersionModel) {
	if r.RelationsDotfile.Versions == nil {
		panic("attempted to access versions but did not fetch it using the .With() syntax")
	}
	return r.RelationsDotfile.Versions
}

// FileVersionModel represents the `json:"FileVersion"` model and is a wrapper for accessing fields and methods
type FileVersionModel struct {
	InnerFileVersion
	RelationsFileVersion
}

// InnerFileVersion holds the actual data
type InnerFileVersion struct {
	ID            string   `json:"id"`
	CreatedAt     DateTime `json:"createdAt"`
	UpdatedAt     DateTime `json:"updatedAt"`
	Content       string   `json:"content"`
	Hash          string   `json:"hash"`
	FileID        string   `json:"fileId"`
	PredecessorID *string  `json:"predecessorId"`
}

// RelationsFileVersion holds the relation data separately
type RelationsFileVersion struct {
	CurrentlyUsed *DotfileModel      `json:"currentlyUsed"`
	File          *DotfileModel      `json:"file"`
	Successor     []FileVersionModel `json:"successor"`
	Predecessor   *FileVersionModel  `json:"predecessor"`
}

func (r FileVersionModel) CurrentlyUsed() (value *DotfileModel, ok bool) {
	if r.RelationsFileVersion.CurrentlyUsed == nil {
		return value, false
	}
	return r.RelationsFileVersion.CurrentlyUsed, true
}

func (r FileVersionModel) File() (value *DotfileModel) {
	if r.RelationsFileVersion.File == nil {
		panic("attempted to access file but did not fetch it using the .With() syntax")
	}
	return r.RelationsFileVersion.File
}

func (r FileVersionModel) Successor() (value []FileVersionModel) {
	if r.RelationsFileVersion.Successor == nil {
		panic("attempted to access successor but did not fetch it using the .With() syntax")
	}
	return r.RelationsFileVersion.Successor
}

func (r FileVersionModel) Predecessor() (value *FileVersionModel, ok bool) {
	if r.RelationsFileVersion.Predecessor == nil {
		return value, false
	}
	return r.RelationsFileVersion.Predecessor, true
}

func (r FileVersionModel) PredecessorID() (value string, ok bool) {
	if r.InnerFileVersion.PredecessorID == nil {
		return value, false
	}
	return *r.InnerFileVersion.PredecessorID, true
}

// --- template query.gotpl ---

// Dotfile acts as a namespaces to access query methods for the Dotfile model
var Dotfile = dotfileQuery{}

// dotfileQuery exposes query functions for the dotfile model
type dotfileQuery struct {
	// ID
	//
	// @required
	ID dotfileQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt dotfileQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt dotfileQueryUpdatedAtDateTime

	// Name
	//
	// @required
	Name dotfileQueryNameString

	// Path
	//
	// @required
	// @unique
	Path dotfileQueryPathString

	// Extension
	//
	// @required
	Extension dotfileQueryExtensionString

	// MimeType
	//
	// @required
	MimeType dotfileQueryMimeTypeString

	// Language
	//
	// @required
	Language dotfileQueryLanguageString

	Current dotfileQueryCurrentRelations

	// CurrentID
	//
	// @optional
	CurrentID dotfileQueryCurrentIDString

	Versions dotfileQueryVersionsRelations
}

func (dotfileQuery) Not(params ...DotfileWhereParam) dotfileDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (dotfileQuery) Or(params ...DotfileWhereParam) dotfileDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (dotfileQuery) And(params ...DotfileWhereParam) dotfileDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type dotfileQueryIDString struct{}

// Set the required value of ID
func (r dotfileQueryIDString) Set(value string) dotfileSetParam {

	return dotfileSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r dotfileQueryIDString) SetIfPresent(value *string) dotfileSetParam {
	if value == nil {
		return dotfileSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryIDString) Equals(value string) dotfileWithPrismaIDEqualsUniqueParam {

	return dotfileWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryIDString) EqualsIfPresent(value *string) dotfileWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return dotfileWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryIDString) In(values []string) dotfileParamUnique {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryIDString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r dotfileQueryIDString) Cursor(cursor string) dotfileCursorParam {
	return dotfileCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r dotfileQueryIDString) Contains(value string) dotfileParamUnique {
	return dotfileParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryIDString) ContainsIfPresent(value *string) dotfileParamUnique {
	if value == nil {
		return dotfileParamUnique{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryIDString) HasPrefix(value string) dotfileParamUnique {
	return dotfileParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryIDString) HasPrefixIfPresent(value *string) dotfileParamUnique {
	if value == nil {
		return dotfileParamUnique{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryIDString) HasSuffix(value string) dotfileParamUnique {
	return dotfileParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryIDString) HasSuffixIfPresent(value *string) dotfileParamUnique {
	if value == nil {
		return dotfileParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r dotfileQueryCreatedAtDateTime) Set(value DateTime) dotfileSetParam {

	return dotfileSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r dotfileQueryCreatedAtDateTime) SetIfPresent(value *DateTime) dotfileSetParam {
	if value == nil {
		return dotfileSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryCreatedAtDateTime) Equals(value DateTime) dotfileWithPrismaCreatedAtEqualsParam {

	return dotfileWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) dotfileWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return dotfileWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryCreatedAtDateTime) In(values []DateTime) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) Before(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Before(*value)
}

func (r dotfileQueryCreatedAtDateTime) After(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.After(*value)
}

func (r dotfileQueryCreatedAtDateTime) BeforeEquals(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

func (r dotfileQueryCreatedAtDateTime) AfterEquals(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type dotfileQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r dotfileQueryUpdatedAtDateTime) Set(value DateTime) dotfileSetParam {

	return dotfileSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r dotfileQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) dotfileSetParam {
	if value == nil {
		return dotfileSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryUpdatedAtDateTime) Equals(value DateTime) dotfileWithPrismaUpdatedAtEqualsParam {

	return dotfileWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) dotfileWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return dotfileWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryUpdatedAtDateTime) In(values []DateTime) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) Before(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Before(*value)
}

func (r dotfileQueryUpdatedAtDateTime) After(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.After(*value)
}

func (r dotfileQueryUpdatedAtDateTime) BeforeEquals(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

func (r dotfileQueryUpdatedAtDateTime) AfterEquals(value DateTime) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type dotfileQueryNameString struct{}

// Set the required value of Name
func (r dotfileQueryNameString) Set(value string) dotfileWithPrismaNameSetParam {

	return dotfileWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r dotfileQueryNameString) SetIfPresent(value *string) dotfileWithPrismaNameSetParam {
	if value == nil {
		return dotfileWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryNameString) Equals(value string) dotfileWithPrismaNameEqualsParam {

	return dotfileWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryNameString) EqualsIfPresent(value *string) dotfileWithPrismaNameEqualsParam {
	if value == nil {
		return dotfileWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryNameString) In(values []string) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryNameString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r dotfileQueryNameString) Contains(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryNameString) ContainsIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryNameString) HasPrefix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryNameString) HasPrefixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryNameString) HasSuffix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryNameString) HasSuffixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryPathString struct{}

// Set the required value of Path
func (r dotfileQueryPathString) Set(value string) dotfileWithPrismaPathSetParam {

	return dotfileWithPrismaPathSetParam{
		data: builder.Field{
			Name:  "path",
			Value: value,
		},
	}

}

// Set the optional value of Path dynamically
func (r dotfileQueryPathString) SetIfPresent(value *string) dotfileWithPrismaPathSetParam {
	if value == nil {
		return dotfileWithPrismaPathSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryPathString) Equals(value string) dotfileWithPrismaPathEqualsUniqueParam {

	return dotfileWithPrismaPathEqualsUniqueParam{
		data: builder.Field{
			Name: "path",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryPathString) EqualsIfPresent(value *string) dotfileWithPrismaPathEqualsUniqueParam {
	if value == nil {
		return dotfileWithPrismaPathEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryPathString) In(values []string) dotfileParamUnique {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileParamUnique{
		data: builder.Field{
			Name: "path",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryPathString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "path",
			Value: direction,
		},
	}
}

func (r dotfileQueryPathString) Cursor(cursor string) dotfileCursorParam {
	return dotfileCursorParam{
		data: builder.Field{
			Name:  "path",
			Value: cursor,
		},
	}
}

func (r dotfileQueryPathString) Contains(value string) dotfileParamUnique {
	return dotfileParamUnique{
		data: builder.Field{
			Name: "path",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryPathString) ContainsIfPresent(value *string) dotfileParamUnique {
	if value == nil {
		return dotfileParamUnique{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryPathString) HasPrefix(value string) dotfileParamUnique {
	return dotfileParamUnique{
		data: builder.Field{
			Name: "path",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryPathString) HasPrefixIfPresent(value *string) dotfileParamUnique {
	if value == nil {
		return dotfileParamUnique{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryPathString) HasSuffix(value string) dotfileParamUnique {
	return dotfileParamUnique{
		data: builder.Field{
			Name: "path",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryPathString) HasSuffixIfPresent(value *string) dotfileParamUnique {
	if value == nil {
		return dotfileParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryExtensionString struct{}

// Set the required value of Extension
func (r dotfileQueryExtensionString) Set(value string) dotfileWithPrismaExtensionSetParam {

	return dotfileWithPrismaExtensionSetParam{
		data: builder.Field{
			Name:  "extension",
			Value: value,
		},
	}

}

// Set the optional value of Extension dynamically
func (r dotfileQueryExtensionString) SetIfPresent(value *string) dotfileWithPrismaExtensionSetParam {
	if value == nil {
		return dotfileWithPrismaExtensionSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryExtensionString) Equals(value string) dotfileWithPrismaExtensionEqualsParam {

	return dotfileWithPrismaExtensionEqualsParam{
		data: builder.Field{
			Name: "extension",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryExtensionString) EqualsIfPresent(value *string) dotfileWithPrismaExtensionEqualsParam {
	if value == nil {
		return dotfileWithPrismaExtensionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryExtensionString) In(values []string) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "extension",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryExtensionString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "extension",
			Value: direction,
		},
	}
}

func (r dotfileQueryExtensionString) Contains(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "extension",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryExtensionString) ContainsIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryExtensionString) HasPrefix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "extension",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryExtensionString) HasPrefixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryExtensionString) HasSuffix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "extension",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryExtensionString) HasSuffixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryMimeTypeString struct{}

// Set the required value of MimeType
func (r dotfileQueryMimeTypeString) Set(value string) dotfileWithPrismaMimeTypeSetParam {

	return dotfileWithPrismaMimeTypeSetParam{
		data: builder.Field{
			Name:  "mimeType",
			Value: value,
		},
	}

}

// Set the optional value of MimeType dynamically
func (r dotfileQueryMimeTypeString) SetIfPresent(value *string) dotfileWithPrismaMimeTypeSetParam {
	if value == nil {
		return dotfileWithPrismaMimeTypeSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryMimeTypeString) Equals(value string) dotfileWithPrismaMimeTypeEqualsParam {

	return dotfileWithPrismaMimeTypeEqualsParam{
		data: builder.Field{
			Name: "mimeType",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryMimeTypeString) EqualsIfPresent(value *string) dotfileWithPrismaMimeTypeEqualsParam {
	if value == nil {
		return dotfileWithPrismaMimeTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryMimeTypeString) In(values []string) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "mimeType",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryMimeTypeString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "mimeType",
			Value: direction,
		},
	}
}

func (r dotfileQueryMimeTypeString) Contains(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "mimeType",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryMimeTypeString) ContainsIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryMimeTypeString) HasPrefix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "mimeType",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryMimeTypeString) HasPrefixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryMimeTypeString) HasSuffix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "mimeType",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryMimeTypeString) HasSuffixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryLanguageString struct{}

// Set the required value of Language
func (r dotfileQueryLanguageString) Set(value string) dotfileWithPrismaLanguageSetParam {

	return dotfileWithPrismaLanguageSetParam{
		data: builder.Field{
			Name:  "language",
			Value: value,
		},
	}

}

// Set the optional value of Language dynamically
func (r dotfileQueryLanguageString) SetIfPresent(value *string) dotfileWithPrismaLanguageSetParam {
	if value == nil {
		return dotfileWithPrismaLanguageSetParam{}
	}

	return r.Set(*value)
}

func (r dotfileQueryLanguageString) Equals(value string) dotfileWithPrismaLanguageEqualsParam {

	return dotfileWithPrismaLanguageEqualsParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryLanguageString) EqualsIfPresent(value *string) dotfileWithPrismaLanguageEqualsParam {
	if value == nil {
		return dotfileWithPrismaLanguageEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryLanguageString) In(values []string) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryLanguageString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "language",
			Value: direction,
		},
	}
}

func (r dotfileQueryLanguageString) Contains(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryLanguageString) ContainsIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryLanguageString) HasPrefix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryLanguageString) HasPrefixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryLanguageString) HasSuffix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "language",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryLanguageString) HasSuffixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryCurrentFileVersion struct{}

type dotfileQueryCurrentRelations struct{}

// Dotfile -> Current
//
// @relation
// @optional
func (dotfileQueryCurrentRelations) Where(
	params ...FileVersionWhereParam,
) dotfileDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileDefaultParam{
		data: builder.Field{
			Name: "current",
			Fields: []builder.Field{
				{
					Name: "is",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

func (dotfileQueryCurrentRelations) Fetch() dotfileToCurrentFindUnique {
	var v dotfileToCurrentFindUnique

	v.query.Operation = "query"
	v.query.Method = "current"
	v.query.Outputs = fileVersionOutput

	return v
}

func (r dotfileQueryCurrentRelations) Link(
	params FileVersionWhereParam,
) dotfileSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return dotfileSetParam{}
	}

	fields = append(fields, f)

	return dotfileSetParam{
		data: builder.Field{
			Name: "current",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r dotfileQueryCurrentRelations) Unlink() dotfileSetParam {
	var v dotfileSetParam

	v = dotfileSetParam{
		data: builder.Field{
			Name: "current",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type dotfileQueryCurrentIDString struct{}

// Set the optional value of CurrentID
func (r dotfileQueryCurrentIDString) Set(value string) dotfileSetParam {

	return dotfileSetParam{
		data: builder.Field{
			Name:  "currentId",
			Value: value,
		},
	}

}

// Set the optional value of CurrentID dynamically
func (r dotfileQueryCurrentIDString) SetIfPresent(value *string) dotfileSetParam {
	if value == nil {
		return dotfileSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of CurrentID dynamically
func (r dotfileQueryCurrentIDString) SetOptional(value *string) dotfileSetParam {
	if value == nil {

		var v *string
		return dotfileSetParam{
			data: builder.Field{
				Name:  "currentId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r dotfileQueryCurrentIDString) Equals(value string) dotfileWithPrismaCurrentIDEqualsParam {

	return dotfileWithPrismaCurrentIDEqualsParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) EqualsIfPresent(value *string) dotfileWithPrismaCurrentIDEqualsParam {
	if value == nil {
		return dotfileWithPrismaCurrentIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r dotfileQueryCurrentIDString) In(values []string) dotfileDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) EqualsOptional(value *string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) IsNull() dotfileDefaultParam {
	var str *string = nil
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) Order(direction types.Direction) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name:  "currentId",
			Value: direction,
		},
	}
}

func (r dotfileQueryCurrentIDString) Contains(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) ContainsIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.Contains(*value)
}

func (r dotfileQueryCurrentIDString) HasPrefix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) HasPrefixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r dotfileQueryCurrentIDString) HasSuffix(value string) dotfileDefaultParam {
	return dotfileDefaultParam{
		data: builder.Field{
			Name: "currentId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r dotfileQueryCurrentIDString) HasSuffixIfPresent(value *string) dotfileDefaultParam {
	if value == nil {
		return dotfileDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type dotfileQueryVersionsFileVersion struct{}

type dotfileQueryVersionsRelations struct{}

// Dotfile -> Versions
//
// @relation
// @required
func (dotfileQueryVersionsRelations) Some(
	params ...FileVersionWhereParam,
) dotfileDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileDefaultParam{
		data: builder.Field{
			Name: "versions",
			Fields: []builder.Field{
				{
					Name: "some",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

// Dotfile -> Versions
//
// @relation
// @required
func (dotfileQueryVersionsRelations) Every(
	params ...FileVersionWhereParam,
) dotfileDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileDefaultParam{
		data: builder.Field{
			Name: "versions",
			Fields: []builder.Field{
				{
					Name: "every",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

func (dotfileQueryVersionsRelations) Fetch(

	params ...FileVersionWhereParam,

) dotfileToVersionsFindMany {
	var v dotfileToVersionsFindMany

	v.query.Operation = "query"
	v.query.Method = "versions"
	v.query.Outputs = fileVersionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{builder.Field{
				Name:     "AND",
				List:     true,
				WrapList: true,
				Fields:   where,
			}},
		})
	}

	return v
}

func (r dotfileQueryVersionsRelations) Link(
	params ...FileVersionWhereParam,
) dotfileSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return dotfileSetParam{
		data: builder.Field{
			Name: "versions",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r dotfileQueryVersionsRelations) Unlink(
	params ...FileVersionWhereParam,
) dotfileSetParam {
	var v dotfileSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = dotfileSetParam{
		data: builder.Field{
			Name: "versions",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// FileVersion acts as a namespaces to access query methods for the FileVersion model
var FileVersion = fileVersionQuery{}

// fileVersionQuery exposes query functions for the fileVersion model
type fileVersionQuery struct {
	// ID
	//
	// @required
	ID fileVersionQueryIDString

	// CreatedAt
	//
	// @required
	CreatedAt fileVersionQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt fileVersionQueryUpdatedAtDateTime

	// Content
	//
	// @required
	Content fileVersionQueryContentString

	// Hash
	//
	// @required
	Hash fileVersionQueryHashString

	CurrentlyUsed fileVersionQueryCurrentlyUsedRelations

	File fileVersionQueryFileRelations

	// FileID
	//
	// @required
	FileID fileVersionQueryFileIDString

	Successor fileVersionQuerySuccessorRelations

	Predecessor fileVersionQueryPredecessorRelations

	// PredecessorID
	//
	// @optional
	PredecessorID fileVersionQueryPredecessorIDString
}

func (fileVersionQuery) Not(params ...FileVersionWhereParam) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (fileVersionQuery) Or(params ...FileVersionWhereParam) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (fileVersionQuery) And(params ...FileVersionWhereParam) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type fileVersionQueryIDString struct{}

// Set the required value of ID
func (r fileVersionQueryIDString) Set(value string) fileVersionSetParam {

	return fileVersionSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r fileVersionQueryIDString) SetIfPresent(value *string) fileVersionSetParam {
	if value == nil {
		return fileVersionSetParam{}
	}

	return r.Set(*value)
}

func (r fileVersionQueryIDString) Equals(value string) fileVersionWithPrismaIDEqualsUniqueParam {

	return fileVersionWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryIDString) EqualsIfPresent(value *string) fileVersionWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return fileVersionWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryIDString) In(values []string) fileVersionParamUnique {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryIDString) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r fileVersionQueryIDString) Cursor(cursor string) fileVersionCursorParam {
	return fileVersionCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r fileVersionQueryIDString) Contains(value string) fileVersionParamUnique {
	return fileVersionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryIDString) ContainsIfPresent(value *string) fileVersionParamUnique {
	if value == nil {
		return fileVersionParamUnique{}
	}
	return r.Contains(*value)
}

func (r fileVersionQueryIDString) HasPrefix(value string) fileVersionParamUnique {
	return fileVersionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryIDString) HasPrefixIfPresent(value *string) fileVersionParamUnique {
	if value == nil {
		return fileVersionParamUnique{}
	}
	return r.HasPrefix(*value)
}

func (r fileVersionQueryIDString) HasSuffix(value string) fileVersionParamUnique {
	return fileVersionParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryIDString) HasSuffixIfPresent(value *string) fileVersionParamUnique {
	if value == nil {
		return fileVersionParamUnique{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fileVersionQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r fileVersionQueryCreatedAtDateTime) Set(value DateTime) fileVersionSetParam {

	return fileVersionSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r fileVersionQueryCreatedAtDateTime) SetIfPresent(value *DateTime) fileVersionSetParam {
	if value == nil {
		return fileVersionSetParam{}
	}

	return r.Set(*value)
}

func (r fileVersionQueryCreatedAtDateTime) Equals(value DateTime) fileVersionWithPrismaCreatedAtEqualsParam {

	return fileVersionWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) fileVersionWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return fileVersionWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryCreatedAtDateTime) In(values []DateTime) fileVersionDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) Before(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.Before(*value)
}

func (r fileVersionQueryCreatedAtDateTime) After(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.After(*value)
}

func (r fileVersionQueryCreatedAtDateTime) BeforeEquals(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

func (r fileVersionQueryCreatedAtDateTime) AfterEquals(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type fileVersionQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r fileVersionQueryUpdatedAtDateTime) Set(value DateTime) fileVersionSetParam {

	return fileVersionSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r fileVersionQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) fileVersionSetParam {
	if value == nil {
		return fileVersionSetParam{}
	}

	return r.Set(*value)
}

func (r fileVersionQueryUpdatedAtDateTime) Equals(value DateTime) fileVersionWithPrismaUpdatedAtEqualsParam {

	return fileVersionWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) fileVersionWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return fileVersionWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryUpdatedAtDateTime) In(values []DateTime) fileVersionDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) Before(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.Before(*value)
}

func (r fileVersionQueryUpdatedAtDateTime) After(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.After(*value)
}

func (r fileVersionQueryUpdatedAtDateTime) BeforeEquals(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

func (r fileVersionQueryUpdatedAtDateTime) AfterEquals(value DateTime) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.AfterEquals(*value)
}

// base struct
type fileVersionQueryContentString struct{}

// Set the required value of Content
func (r fileVersionQueryContentString) Set(value string) fileVersionWithPrismaContentSetParam {

	return fileVersionWithPrismaContentSetParam{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}

}

// Set the optional value of Content dynamically
func (r fileVersionQueryContentString) SetIfPresent(value *string) fileVersionWithPrismaContentSetParam {
	if value == nil {
		return fileVersionWithPrismaContentSetParam{}
	}

	return r.Set(*value)
}

func (r fileVersionQueryContentString) Equals(value string) fileVersionWithPrismaContentEqualsParam {

	return fileVersionWithPrismaContentEqualsParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryContentString) EqualsIfPresent(value *string) fileVersionWithPrismaContentEqualsParam {
	if value == nil {
		return fileVersionWithPrismaContentEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryContentString) In(values []string) fileVersionDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryContentString) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r fileVersionQueryContentString) Contains(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryContentString) ContainsIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fileVersionQueryContentString) HasPrefix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryContentString) HasPrefixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r fileVersionQueryContentString) HasSuffix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryContentString) HasSuffixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fileVersionQueryHashString struct{}

// Set the required value of Hash
func (r fileVersionQueryHashString) Set(value string) fileVersionWithPrismaHashSetParam {

	return fileVersionWithPrismaHashSetParam{
		data: builder.Field{
			Name:  "hash",
			Value: value,
		},
	}

}

// Set the optional value of Hash dynamically
func (r fileVersionQueryHashString) SetIfPresent(value *string) fileVersionWithPrismaHashSetParam {
	if value == nil {
		return fileVersionWithPrismaHashSetParam{}
	}

	return r.Set(*value)
}

func (r fileVersionQueryHashString) Equals(value string) fileVersionWithPrismaHashEqualsParam {

	return fileVersionWithPrismaHashEqualsParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryHashString) EqualsIfPresent(value *string) fileVersionWithPrismaHashEqualsParam {
	if value == nil {
		return fileVersionWithPrismaHashEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryHashString) In(values []string) fileVersionDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryHashString) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "hash",
			Value: direction,
		},
	}
}

func (r fileVersionQueryHashString) Contains(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryHashString) ContainsIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fileVersionQueryHashString) HasPrefix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryHashString) HasPrefixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r fileVersionQueryHashString) HasSuffix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "hash",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryHashString) HasSuffixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fileVersionQueryCurrentlyUsedDotfile struct{}

type fileVersionQueryCurrentlyUsedRelations struct{}

// FileVersion -> CurrentlyUsed
//
// @relation
// @optional
func (fileVersionQueryCurrentlyUsedRelations) Where(
	params ...DotfileWhereParam,
) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "currentlyUsed",
			Fields: []builder.Field{
				{
					Name: "is",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

func (fileVersionQueryCurrentlyUsedRelations) Fetch() fileVersionToCurrentlyUsedFindUnique {
	var v fileVersionToCurrentlyUsedFindUnique

	v.query.Operation = "query"
	v.query.Method = "currentlyUsed"
	v.query.Outputs = dotfileOutput

	return v
}

func (r fileVersionQueryCurrentlyUsedRelations) Link(
	params DotfileWhereParam,
) fileVersionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return fileVersionSetParam{}
	}

	fields = append(fields, f)

	return fileVersionSetParam{
		data: builder.Field{
			Name: "currentlyUsed",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r fileVersionQueryCurrentlyUsedRelations) Unlink() fileVersionSetParam {
	var v fileVersionSetParam

	v = fileVersionSetParam{
		data: builder.Field{
			Name: "currentlyUsed",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type fileVersionQueryFileDotfile struct{}

type fileVersionQueryFileRelations struct{}

// FileVersion -> File
//
// @relation
// @required
func (fileVersionQueryFileRelations) Where(
	params ...DotfileWhereParam,
) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "file",
			Fields: []builder.Field{
				{
					Name: "is",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

func (fileVersionQueryFileRelations) Fetch() fileVersionToFileFindUnique {
	var v fileVersionToFileFindUnique

	v.query.Operation = "query"
	v.query.Method = "file"
	v.query.Outputs = dotfileOutput

	return v
}

func (r fileVersionQueryFileRelations) Link(
	params DotfileWhereParam,
) fileVersionWithPrismaFileSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return fileVersionWithPrismaFileSetParam{}
	}

	fields = append(fields, f)

	return fileVersionWithPrismaFileSetParam{
		data: builder.Field{
			Name: "file",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r fileVersionQueryFileRelations) Unlink() fileVersionWithPrismaFileSetParam {
	var v fileVersionWithPrismaFileSetParam

	v = fileVersionWithPrismaFileSetParam{
		data: builder.Field{
			Name: "file",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type fileVersionQueryFileIDString struct{}

// Set the required value of FileID
func (r fileVersionQueryFileIDString) Set(value string) fileVersionSetParam {

	return fileVersionSetParam{
		data: builder.Field{
			Name:  "fileId",
			Value: value,
		},
	}

}

// Set the optional value of FileID dynamically
func (r fileVersionQueryFileIDString) SetIfPresent(value *string) fileVersionSetParam {
	if value == nil {
		return fileVersionSetParam{}
	}

	return r.Set(*value)
}

func (r fileVersionQueryFileIDString) Equals(value string) fileVersionWithPrismaFileIDEqualsParam {

	return fileVersionWithPrismaFileIDEqualsParam{
		data: builder.Field{
			Name: "fileId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryFileIDString) EqualsIfPresent(value *string) fileVersionWithPrismaFileIDEqualsParam {
	if value == nil {
		return fileVersionWithPrismaFileIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryFileIDString) In(values []string) fileVersionDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "fileId",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryFileIDString) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "fileId",
			Value: direction,
		},
	}
}

func (r fileVersionQueryFileIDString) Contains(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "fileId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryFileIDString) ContainsIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fileVersionQueryFileIDString) HasPrefix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "fileId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryFileIDString) HasPrefixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r fileVersionQueryFileIDString) HasSuffix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "fileId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryFileIDString) HasSuffixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasSuffix(*value)
}

// base struct
type fileVersionQuerySuccessorFileVersion struct{}

type fileVersionQuerySuccessorRelations struct{}

// FileVersion -> Successor
//
// @relation
// @required
func (fileVersionQuerySuccessorRelations) Some(
	params ...FileVersionWhereParam,
) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "successor",
			Fields: []builder.Field{
				{
					Name: "some",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

// FileVersion -> Successor
//
// @relation
// @required
func (fileVersionQuerySuccessorRelations) Every(
	params ...FileVersionWhereParam,
) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "successor",
			Fields: []builder.Field{
				{
					Name: "every",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

func (fileVersionQuerySuccessorRelations) Fetch(

	params ...FileVersionWhereParam,

) fileVersionToSuccessorFindMany {
	var v fileVersionToSuccessorFindMany

	v.query.Operation = "query"
	v.query.Method = "successor"
	v.query.Outputs = fileVersionOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name: "where",
			Fields: []builder.Field{builder.Field{
				Name:     "AND",
				List:     true,
				WrapList: true,
				Fields:   where,
			}},
		})
	}

	return v
}

func (r fileVersionQuerySuccessorRelations) Link(
	params ...FileVersionWhereParam,
) fileVersionSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionSetParam{
		data: builder.Field{
			Name: "successor",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r fileVersionQuerySuccessorRelations) Unlink(
	params ...FileVersionWhereParam,
) fileVersionSetParam {
	var v fileVersionSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = fileVersionSetParam{
		data: builder.Field{
			Name: "successor",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

// base struct
type fileVersionQueryPredecessorFileVersion struct{}

type fileVersionQueryPredecessorRelations struct{}

// FileVersion -> Predecessor
//
// @relation
// @optional
func (fileVersionQueryPredecessorRelations) Where(
	params ...FileVersionWhereParam,
) fileVersionDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessor",
			Fields: []builder.Field{
				{
					Name: "is",
					Fields: []builder.Field{builder.Field{
						Name:     "AND",
						List:     true,
						WrapList: true,
						Fields:   fields,
					}},
				},
			},
		},
	}
}

func (fileVersionQueryPredecessorRelations) Fetch() fileVersionToPredecessorFindUnique {
	var v fileVersionToPredecessorFindUnique

	v.query.Operation = "query"
	v.query.Method = "predecessor"
	v.query.Outputs = fileVersionOutput

	return v
}

func (r fileVersionQueryPredecessorRelations) Link(
	params FileVersionWhereParam,
) fileVersionSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return fileVersionSetParam{}
	}

	fields = append(fields, f)

	return fileVersionSetParam{
		data: builder.Field{
			Name: "predecessor",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorRelations) Unlink() fileVersionSetParam {
	var v fileVersionSetParam

	v = fileVersionSetParam{
		data: builder.Field{
			Name: "predecessor",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

// base struct
type fileVersionQueryPredecessorIDString struct{}

// Set the optional value of PredecessorID
func (r fileVersionQueryPredecessorIDString) Set(value string) fileVersionSetParam {

	return fileVersionSetParam{
		data: builder.Field{
			Name:  "predecessorId",
			Value: value,
		},
	}

}

// Set the optional value of PredecessorID dynamically
func (r fileVersionQueryPredecessorIDString) SetIfPresent(value *string) fileVersionSetParam {
	if value == nil {
		return fileVersionSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of PredecessorID dynamically
func (r fileVersionQueryPredecessorIDString) SetOptional(value *string) fileVersionSetParam {
	if value == nil {

		var v *string
		return fileVersionSetParam{
			data: builder.Field{
				Name:  "predecessorId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r fileVersionQueryPredecessorIDString) Equals(value string) fileVersionWithPrismaPredecessorIDEqualsParam {

	return fileVersionWithPrismaPredecessorIDEqualsParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) EqualsIfPresent(value *string) fileVersionWithPrismaPredecessorIDEqualsParam {
	if value == nil {
		return fileVersionWithPrismaPredecessorIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r fileVersionQueryPredecessorIDString) In(values []string) fileVersionDefaultParam {
	var fields []builder.Field
	for _, v := range values {
		fields = append(fields, builder.Field{
			Value: v,
		})
	}
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:   "in",
					List:   true,
					Fields: fields,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) EqualsOptional(value *string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) IsNull() fileVersionDefaultParam {
	var str *string = nil
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) Order(direction types.Direction) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name:  "predecessorId",
			Value: direction,
		},
	}
}

func (r fileVersionQueryPredecessorIDString) Contains(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) ContainsIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.Contains(*value)
}

func (r fileVersionQueryPredecessorIDString) HasPrefix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) HasPrefixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasPrefix(*value)
}

func (r fileVersionQueryPredecessorIDString) HasSuffix(value string) fileVersionDefaultParam {
	return fileVersionDefaultParam{
		data: builder.Field{
			Name: "predecessorId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r fileVersionQueryPredecessorIDString) HasSuffixIfPresent(value *string) fileVersionDefaultParam {
	if value == nil {
		return fileVersionDefaultParam{}
	}
	return r.HasSuffix(*value)
}
